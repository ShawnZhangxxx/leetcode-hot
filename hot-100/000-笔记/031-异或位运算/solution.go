/*
__author__ = 'robin-luo'
__date__ = '2023/03/07 14:02'
*/

package main




func main() {

	//a^a = 0    0^a=a




	//n&(~n+1) == n & -n  取二进制a最右侧的1     取最右侧的1的状态


	/**
		异或题
	 */
	//数组中a,b为奇数个,其他数为偶数个,求a和b?
	// =>全部异或一遍得到a^b ,找最右侧1,a,b分为俩个阵营,重新遍历数组,分俩阵营异或分别得到a和b

	//数组中 其他数都出现m次,只有一个数出现少于m次.求这个数?.
	//之后统计每一位出现的次数, 按位统计出现次数,如果这个位不是m的整数倍,就有问题这个位就是1,那个数



	/*
	*	位运算题
	*/

	//1.判断一个整数是不是2的幂?
	//解答: 提前最右侧1,跟这个n比较就行了 n>0 && n == (n & -n)  n必须大于0

	//2.判断一个整数是不是3的幂?
	//解答: n>0 && 3^19 % n == 0  整数中最大的

	//n非负数,返回大于等于n最小的2的幂 ?
	//解答: 减1之后为了防止这个数就是2的幂,将最高位后面的位都变成1,之后再加1 ,   0001111 + 1

	//区间[left,right] 所有数求&结果?
	// while(left<right){  //&运算 见到0就为0, 从right开始,每次和right-1 &运算,都是干掉最右侧的1,因为-1之后,那个最右侧的1就变为0了
	//	right -= right & -right
	//}
	//return right

	//反转一个二进制的状态,不是0变1,1变0,是逆序,超自然版()
	//0 1 0 1
	//1 0 1 0


	//汉明距离 x与y 二进制有多少不同的位 x^y 之后数1的个数


}


